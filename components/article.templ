package components

import (
	"fmt"
	"time"
	"strings"
	"hash/fnv"
)

type ArticleListArgs struct {
	Articles []ArticleArgs
}

templ ArticleList(a ArticleListArgs) {
	for _, item := range a.Articles {
		@Article(item)
	}
}

type ArticleArgs struct {
	ID          string
	Title       string
	Description string
	PublishedAt time.Time
	Tags        []string
	Content     string
}

templ Article(a ArticleArgs) {
	<article class="o-relative">
		<h2 id={ a.ID } class="o-group">
			<a class="o-not-prose" href={ templ.URL(fmt.Sprintf("/release/%s", a.ID)) }>{ a.Title }</a>
			<a
				class="o-opacity-0 group-hover:o-opacity-100 o-transition-opacity"
				href={ templ.URL(fmt.Sprintf("#%s", a.ID)) }
			>
				#
			</a>
		</h2>
		<p class="o-text-caption">{ a.Description }</p>
		<div class="lg:o-absolute lg:o--left-40 lg:o-max-w-40 lg:o-top-0 lg:o-mr-2 o-flex o-flex-row o-gap-2 lg:o-gap-0 o-items-center lg:o-items-start lg:o-flex-col">
			if !a.PublishedAt.IsZero() {
				<p class="o-text-caption o-text-nowrap">{ a.PublishedAt.Format("02 Jan 2006") }</p>
			}
			<div class="o-flex o-flex-wrap o-gap-2">
				<style>
					#tag:where([color-scheme=dark] *) {
						color: var(--tag-text-light);
					}
				</style>
				for _, t := range a.Tags {
					@Tag(t)
				}
			</div>
		</div>
		@templ.Raw(a.Content)
	</article>
}

templ Tag(name string) {
	<div id="tag" class={ "o-p-1 o-rounded o-border o-text-xs o-text-nowrap o-leading-3", tagStyle(name) }>{ name }</div>
}

css tagStyle(tag string) {
	--tag-color: { templ.SafeCSSProperty(tagBaseColor(tag)) };
	--tag-bg: color-mix(in srgb, var(--tag-color) 20%, transparent);
	--tag-text-dark: color-mix(in srgb, var(--tag-color) 70%, black);
	--tag-text-light: color-mix(in srgb, var(--tag-color) 80%, white);
	background-color: var(--tag-bg);
	border-color: var(--tag-bg);
	color: var(--tag-text-dark);
}

func tagBaseColor(tag string) string {
	h, s, l := stringToHSL(tag)
	return fmt.Sprintf("hsl(%d %d%% %d%%)", h, s, l)
}

// HSLFromString produces H, S, L in ranges:
// H: 0-359
// S: 45-90
// L: 28-64
func stringToHSL(s string) (h, sat, light int) {
	h32 := fnvHash32(s)

	// check if type hint exists for `s`
	var hint *ColorHint
    lower := strings.ToLower(s)
    for key, hRange := range colorHints {
        if strings.Contains(lower, key) {
            hint = &hRange
            break
        }
    }

    if hint == nil {
        // Default random hue
        h = int(h32 % 360)
    } else {
        // deterministic hue inside hint range
        span := hueRangeSize(*hint)
        offset := int((h32 >> 2) % uint32(span))
        h = wrapHue(hint.MinHue + offset)
    }


	// Use different bit slices so small changes in input change H/S/L
	sat = 50 + int((h32>>8)%41)                         // 50-90
	light = 28 + int((h32>>16)%37)                      // 28-64
	return
}

func fnvHash32(s string) uint32 {
	h := fnv.New32a()
	_, _ = h.Write([]byte(s))
	return h.Sum32()
}

type ColorHint struct {
    MinHue int
    MaxHue int
}

var colorHints = map[string]ColorHint{
    "bug":      {MinHue: 350, MaxHue: 15},   // red range (wraps around)
    "feat":  {MinHue: 90, MaxHue: 150},   // greenish
}

func hueRangeSize(h ColorHint) int {
    if h.MinHue <= h.MaxHue {
        return h.MaxHue - h.MinHue + 1
    }
    // wraparound (e.g. 350 â†’ 20)
    return (360 - h.MinHue) + (h.MaxHue + 1)
}

func wrapHue(v int) int {
    v %= 360
    if v < 0 { v += 360 }
    return v
}